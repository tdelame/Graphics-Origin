/**
 * Warning: This header is automatically generated by cmake, using 
 * lib/graphics_origin.h.in as input. You should only make your modifications
 * in lib/graphics_origin.h.in and run cmake. Otherwise, any modifications you
 * have made will disappear after cmake is run. 
 */
# ifndef GRAPHICS_ORIGIN_PROJECT_H_
# define GRAPHICS_ORIGIN_PROJECT_H_

# define GRAPHICS_ORIGIN_MAJOR @Graphics-Origin_VERSION_MAJOR@
# define GRAPHICS_ORIGIN_MINOR @Graphics-Origin_VERSION_MINOR@

/*******************************
 ** Types related definitions **
 *******************************/
# include <float.h>
# include <cstdint>
namespace graphics_origin {
  
  /** Real type for any CPU computations. */
  typedef double real;
  static const real REAL_EPSILON = DBL_EPSILON;
  /** Real type used by OpenGL internally.
   * 
   * Double precision is not always possible for gl_Position, the built-in
   * OpenGL variable that store the position of a vertex. Still, you can use
   * double precision for vertex attributes, in order to make some computations
   * in shaders. But remember that, in the end, vertex positions will have the
   * precision of \c gl_real. 
   */
  typedef float gl_real;
}
/** Maximum positive value stored in a \c real. */
# define REAL_MIN DBL_MIN
/** Minimum positive value stored in a \c real. */
# define REAL_MAX DBL_MAX

/****************************
 ** Preprocessor utilities **
 ****************************/
// Transmit arguments list
#if _MSC_VER >= 1400
# define GO_PP_PASS_ARGS_LEFT (
# define GO_PP_PASS_ARGS_RIGHT )
# define GO_PP_PASS_ARGS(...)  GO_PP_PASS_ARGS_LEFT __VA_ARGS__ GO_PP_PASS_ARGS_RIGHT
#else
# define GO_PP_PASS_ARGS(...)  (__VA_ARGS__)
#endif

// Concatenate any two arguments
# define GO_JOIN_HELPER_HELPER(x,y) x##y
# define GO_JOIN_HELPER( x, y ) GO_JOIN_HELPER_HELPER( x, y )
# define GO_PP_JOIN( x, y ) GO_JOIN_HELPER( x, y )

// Count the number of arguments
#if _MSC_VER >= 1400
# define GO_PP_VA_NUM_ARGS_HELPER(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...)    N
# define GO_PP_VA_NUM_ARGS_REVERSE_SEQUENCE            10, 9, 8, 7, 6, 5, 4, 3, 2, 1
# define GO_PP_VA_NUM_ARGS_LEFT_PARENTHESIS (
# define GO_PP_VA_NUM_ARGS_RIGHT_PARENTHESIS )
# define GO_PP_VA_NUM_ARGS(...)  GO_PP_VA_NUM_ARGS_HELPER GO_PP_VA_NUM_ARGS_LEFT_PARENTHESIS __VA_ARGS__, GO_PP_VA_NUM_ARGS_REVERSE_SEQUENCE GO_PP_VA_NUM_ARGS_RIGHT_PARENTHESIS
#else
# define GO_PP_VA_NUM_ARGS_HELPER(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, N, ...)  N
# define GO_PP_VA_NUM_ARGS(...)  GO_PP_VA_NUM_ARGS_HELPER(__VA_ARGS__, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
#endif

// Stringizes anything
#define GO_STRINGIZE_HELPER(token)   #token
#define GO_STRINGIZE(token)          GO_STRINGIZE_HELPER(token)

// Expand any number of arguments into a list of operations called with those arguments
#define GO_PP_EXPAND_ARGS_1(op, a1)                                            \
  op(a1)
#define GO_PP_EXPAND_ARGS_2(op, a1, a2)                                        \
  op(a1) op(a2)
#define GO_PP_EXPAND_ARGS_3(op, a1, a2, a3)                                    \
  op(a1) op(a2) op(a3)
#define GO_PP_EXPAND_ARGS_4(op, a1, a2, a3, a4)                                \
  op(a1) op(a2) op(a3) op(a4)
#define GO_PP_EXPAND_ARGS_5(op, a1, a2, a3, a4, a5)                            \
  op(a1) op(a2) op(a3) op(a4) op(a5)
#define GO_PP_EXPAND_ARGS_6(op, a1, a2, a3, a4, a5, a6)                        \
  op(a1) op(a2) op(a3) op(a4) op(a5) op(a6)
#define GO_PP_EXPAND_ARGS_7(op, a1, a2, a3, a4, a5, a6, a7)                    \
  op(a1) op(a2) op(a3) op(a4) op(a5) op(a6) op(a7)
#define GO_PP_EXPAND_ARGS_8(op, a1, a2, a3, a4, a5, a6, a7, a8)                \
  op(a1) op(a2) op(a3) op(a4) op(a5) op(a6) op(a7) op(a8)
#define GO_PP_EXPAND_ARGS_9(op, a1, a2, a3, a4, a5, a6, a7, a8, a9)            \
  op(a1) op(a2) op(a3) op(a4) op(a5) op(a6) op(a7) op(a8) op(a9)
# define GO_PP_EXPAND_ARGS_10(op, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)     \
  op(a1) op(a2) op(a3) op(a4) op(a5) op(a6) op(a7) op(a8) op(a9) op(a10)
# define GO_PP_EXPAND_ARGS(op, ...)                                            \
  GO_PP_JOIN(GO_PP_EXPAND_ARGS_, GO_PP_VA_NUM_ARGS(__VA_ARGS__)) GO_PP_PASS_ARGS(op, __VA_ARGS__)

/*********************
 ** API definitions **
 *********************/
# ifdef _WIN32
#  ifdef GO_EXPORTS
#   define GO_API __declspec(dllexport)
#  else
#   define GO_API __declspec(dllimport)
#  endif
# else
#  define GO_API
# endif

/************************
 ** Debug and warnings **
 ************************/
// Get the pretty name of the current function
# ifdef _MSC_VER
#   define GO_PRETTY_FUNCTION __FUNCTION__
# else
#   define GO_PRETTY_FUNCTION __PRETTY_FUNCTION__
# endif

// Break the program execution.
# ifdef _WIN32
#  define GO_BREAK __debugbreak()
# else
#  include <csignal>
#  // The program will be stopped, and can be continued in gdb by typing continue
#  define GO_BREAK (void)std::raise(SIGINT)
# endif


// Print meaningful warning during the compilation.
# if _MSC_VER
#   define FILE_LINE_LINK __FILE__ "(" GO_STRINGIZE(__LINE__) ") : "
#   define WARN(msg) __pragma(message (FILE_LINE_LINK "warning: " #msg))
# else
#   define WARN(msg) _Pragma(message ("warning: " #msg))
# endif

// MSVC only provides an OpenMP 2.0 implementation, and this implementation is buggy.
// Thus, some features are not available yet and hacks must be used instead. Those
// warnings alert the user about those limitations and can be used as a reminder
// to remove hacks once a proper OpenMP implementation is available.
# if _MSC_VER
#   define GO_MSVC_OMP_THRUST_BUGS WARN("MSVC's OpenMP implementation is not good enough to compile CUDA Thrust sort() function")
#   define GO_MSVC_OMP_NO_UNSIGNED_FOR_INDEX WARN( "MSVC's OpenMP implementation does not allow unsigned index variable in OpenMP for statement" )
#   define GO_MSVC_OMP_NO_ATOMIC_CAPTURE WARN("MSVC's OpenMP implementation does not support capture directive for an atomic construct")
#   define GO_MSVC_OMP_NO_CUSTOM_REDUCTION WARN("MSVC's OpenMP implementation does not support custom reduction operation")
# endif

// This template allows to write the following static assert, in a function
// template or a class template, in order to clearly tell the user that an
// implementation is necessary:
//   static_assert( 
//     implementation_required<param>::value,
//     "Please, provide an implementation of X because Y");
// The "trick" is that the compiler has to wait for an actual instantiation
// of the class template in order to know the value. Otherwise, if we used
// static_assert( false, ""), it will always fail.
# include <type_traits>
template< typename... parameters >
struct implementation_required :
	public std::false_type 
{};
	

//TODO: remove
# define GO_NAMESPACE graphics_origin
# define BEGIN_GO_NAMESPACE namespace GO_NAMESPACE {
# define END_GO_NAMESPACE }

/*******************************
 ** Options: not used anymore **
 *******************************/
#cmakedefine GO_USE_OPENMP
#cmakedefine GO_USE_OPENCL
# endif
